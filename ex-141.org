* Exercise 141
If you are asked to design the function `cat`, which consumes a list of strings and
appends them all into one long string, you are guaranteed to end up with this partial
definition:

#+begin_src racket
; List-of-string -> String
; concatenates all strings in l into one long string
(check-expect (cat '()) "")
(check-expect (cat (cons "a" (cons "b" '()))) "ab")
(check-expect
  (cat (cons "ab" (cons "cd" (cons "ef" '())))
       "abcdef"))

(define (cat l)
  (cond [(empty? l) ""]
       [else (... (first l) ... (cat (rest l)) ...)]))
#+end_src

Fill in the table in Figure 57. Guess a function that can create the desired result
from the values computed by the sub-expressions.

| l                                    | (first l) | (rest l)                    | (cat (rest l)) | (cat l)  |
|--------------------------------------+-----------+-----------------------------+----------------+----------|
| (cons "a" (cons "b" '()))            | "a"       | (cons "b" '())              | "b"            | "ab"     |
|--------------------------------------+-----------+-----------------------------+----------------+----------|
| (cons "ab" (cons "cd (cons "ef '())) | "ab"      | (cons "cd" (cons "ef" '())) | "cdef"         | "abcdef" |
|--------------------------------------+-----------+-----------------------------+----------------+----------|

We should use =string-append=.
